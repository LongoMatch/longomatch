#define _CRT_SECURE_NO_WARNINGS 1

#include <glib.h>
#include <stdio.h>

#ifdef G_OS_WIN32
#include <windows.h>
#include <math.h>
#else
#define __USE_GNU
#include <fenv.h>
#include <ldt_keeper.h>
#include <winbase.h>
#endif

#include "mscodec.h"

#if 0
typedef struct {
  void * memblock;
  size_t size;
} MemChunk;

static GList * chunks = NULL;

void
my_log_malloc (void * memblock, size_t size)
{
  MemChunk * chunk;

  chunk = g_new (MemChunk, 1);
  chunk->memblock = memblock;
  chunk->size = size;

  chunks = g_list_append (chunks, chunk);
}

static void
my_log_dump_mem_chunks ()
{
  guint i = 1;
  GList * cur;

  for (cur = chunks; cur != NULL; cur = cur->next)
  {
    MemChunk * chunk = cur->data;
    gchar * filename;
    FILE * fp;

    filename = g_strdup_printf ("chunk_%02d.bin", i);

    fp = fopen (filename, "wb");
    g_assert (fp != NULL);

    fwrite (chunk->memblock, chunk->size, 1, fp);

    fclose (fp);

    g_free (filename);

    i++;
  }
}
#endif

#ifdef G_OS_WIN32

static void * __cdecl
my_malloc (size_t size)
{
  void * result;

  result = malloc (size);
  memset (result, 0xCD, size);

  printf ("malloc(%d)\n", size);

#if 0
  my_log_malloc (result, size);
#endif

  return result;
}

static void __cdecl
my_free (void * memblock)
{
  free (memblock);

  printf ("free(%p)\n", memblock);
}

static void * __cdecl
my_memset (void * dst, int val, int size)
{
  void * result;

  result = memset (dst, val, size);

  printf ("memset(dest, %d, %d)\n", val, size);

  return result;
}

static double __cdecl
my__CIexp ()
{
  double x, result;

  __asm
  {
    fstp x;
    fwait;
  }

  result = exp(x);
  printf ("_CIexp(%lf) => %lf\n", x, result);
  return result;
}

static double __cdecl
my__CIcos ()
{
  double x, result;

  __asm
  {
    fstp x;
    fwait;
  }

  result = cos(x);
  printf ("_CIcos(%lf) => %lf\n", x, result);
  return result;
}

static double __cdecl
my__CIlog10 ()
{
  double x, result;

  __asm
  {
    fstp x;
    fwait;
  }

  result = log10(x);
  printf ("_CIlog10(%lf) => %lf\n", x, result);
  return result;
}

static double __cdecl
my__CIsqrt ()
{
  double x, result;

  __asm
  {
    fstp x;
    fwait;
  }

  result = sqrt(x);
  printf ("_CIsqrt(%lf) => %lf\n", x, result);
  return result;
}

typedef struct {
  gchar * name;
  gpointer replacement;
} OverriddenFunction;

static const OverriddenFunction overridden_functions[] =
{
  { "malloc",   my_malloc },
  { "free",     my_free   },
  { "memset",   my_memset },
  { "_CIexp",   my__CIexp },
  { "_CIcos",   my__CIcos },
  { "_CIlog10", my__CIlog10 },
  { "_CIsqrt",  my__CIsqrt },
  { NULL,       NULL      },
};

#define OPCODE_JMP 0xE9

static void
patch_crt_functions ()
{
  HMODULE mod;
  guint i;

  mod = GetModuleHandleA ("C:\\Windows\\winsxs\\x86_microsoft.vc80.crt_1fc8b3b9a1e18e3b_8.0.50727.1434_none_d08b6002442c891f\\msvcr80.dll");
  g_assert (mod != NULL);

  for (i = 0; overridden_functions[i].name != NULL; i++)
  {
    const OverriddenFunction * of = &overridden_functions[i];
    guint8 * func;
    DWORD old_protect;

    func = (guint8 *) GetProcAddress (mod, of->name);
    g_assert (func != NULL);

    VirtualProtect (func, 5, PAGE_EXECUTE_READWRITE, &old_protect);

    *func = OPCODE_JMP;
    *((guint32 *) (func + 1)) = (guint8 *) of->replacement - (func + 5);
  }
}

#if 0
typedef struct {
  const gchar * name;
  guint32 start;
  guint32 end;
} Segment;

static const Segment rw_segments[] =
{
  { ".data",    0x006FD000, 0x007B0400 },
  { "MMXMEDAT", 0x007B1000, 0x007B2C00 },
  { "IADATA1",  0x007B3000, 0x007B5800 },
  { "IARDATA2", 0x007B6000, 0x007B6200 },
  { "MMXDATA1", 0x007B7000, 0x007B8A00 },
  { "H26xColo", 0x007B9000, 0x007C0800 },
  { "RT_DATA",  0x007C1000, 0x007C1400 },
  { NULL,       0,          0          },
};

static void
block_rw_segments (HMODULE mod)
{
  guint i;
  
  for (i = 0; rw_segments[i].name != NULL; i++)
  {
    const Segment * seg = &rw_segments[i];
    DWORD old_protect;
    BOOL ret;

    g_debug ("Blocking access to '%s'", seg->name);
    ret = VirtualProtect ((guint8 *) mod + (seg->start - 0x400000),
      seg->end - seg->start, PAGE_READONLY /* PAGE_NOACCESS */, &old_protect);
    g_assert (ret);
  }
}

typedef void (*CpuCheckFunc) (void);
#endif

#endif

gint
main (gint argc, gchar * argv[])
{
  HMODULE mod;
  MSEncoderCreateFunc create_func;
  MSEncoderDestroyFunc destroy_func;
  MSEncoder * encoder = NULL;
  gint ret;
  static guint8 inbuf[640] = { 0x15, 0x00, 0x08, 0x00, 0x12, 0x00, 0xf3, 0xff, 0x06, 0x00, 0x0c, 0x00, 0xf3, 0xff, 0x3c, 0x00, 0xfa, 0xff, 0x10, 0x00, 0x51, 0x00, 0xf4, 0xff, 0x09, 0x00, 0x23, 0x00, 0xf1, 0xff, 0xc5, 0xff, 0xbf, 0xff, 0xb0, 0xff, 0xae, 0xff, 0xce, 0xff, 0xb1, 0xff, 0xf9, 0xff, 0x48, 0x00, 0x07, 0x00, 0x03, 0x00, 0x3d, 0x00, 0x1c, 0x00, 0xed, 0xff, 0xf2, 0xff, 0x0a, 0x00, 0x2a, 0x00, 0xf4, 0xff, 0x0d, 0x00, 0x5c, 0x00, 0x36, 0x00, 0x5b, 0x00, 0x6d, 0x00, 0xa1, 0x00, 0x19, 0x01, 0xe2, 0x00, 0x7f, 0x00, 0x71, 0x00, 0x79, 0x00, 0x55, 0x00, 0x2a, 0x00, 0x3b, 0x00, 0x30, 0x00, 0x26, 0x00, 0x75, 0x00, 0x7f, 0x00, 0x6f, 0x00, 0x47, 0x00, 0x9a, 0xff, 0xd0, 0xff, 0xe0, 0xff, 0x20, 0xff, 0x46, 0xff, 0x7a, 0xff, 0x87, 0xff, 0xa1, 0xff, 0x66, 0xff, 0x58, 0xff, 0x74, 0xff, 0x0b, 0xff, 0x9b, 0xfe, 0x2a, 0xff, 0x4e, 0xff, 0x3c, 0xff, 0xb8, 0xff, 0xa3, 0xff, 0x89, 0xff, 0x8c, 0xff, 0x8d, 0xff, 0x98, 0xff, 0x99, 0xff, 0x90, 0xff, 0x80, 0xff, 0x2e, 0x00, 0x80, 0x00, 0x28, 0x00, 0x58, 0x00, 0x5e, 0x00, 0x4e, 0x00, 0x7a, 0x00, 0x22, 0x00, 0x0a, 0x00, 0x7d, 0x00, 0x4b, 0x00, 0x2e, 0x00, 0x98, 0x00, 0x9b, 0x00, 0x61, 0x00, 0x33, 0x00, 0x50, 0x00, 0x7d, 0x00, 0x5b, 0x00, 0x4f, 0x00, 0x6c, 0x00, 0x71, 0x00, 0x33, 0x00, 0xd7, 0xff, 0xcd, 0xff, 0xec, 0xff, 0xc1, 0xff, 0xb0, 0xff, 0xf2, 0xff, 0x4a, 0x00, 0x79, 0x00, 0x51, 0x00, 0x58, 0x00, 0x5f, 0x00, 0x22, 0x00, 0xc4, 0xff, 0x6b, 0xff, 0x77, 0xff, 0x6c, 0xff, 0x61, 0xff, 0xbb, 0xff, 0x09, 0x00, 0xfb, 0xff, 0xd0, 0xff, 0x29, 0x00, 0x68, 0x00, 0x41, 0x00, 0x1e, 0x00, 0xf2, 0xff, 0x20, 0x00, 0x28, 0x00, 0xce, 0xff, 0xe3, 0xff, 0x0e, 0x00, 0x10, 0x00, 0x34, 0x00, 0x4a, 0x00, 0x5c, 0x00, 0x85, 0x00, 0x73, 0x00, 0x39, 0x00, 0x51, 0x00, 0x45, 0x00, 0x04, 0x00, 0x29, 0x00, 0x0c, 0x00, 0xd5, 0xff, 0xe7, 0xff, 0xc7, 0xff, 0x05, 0x00, 0x06, 0x00, 0x94, 0xff, 0xbd, 0xff, 0xea, 0xff, 0xf3, 0xff, 0xde, 0xff, 0xaa, 0xff, 0xb7, 0xff, 0x8c, 0xff, 0x51, 0xff, 0x48, 0xff, 0x4e, 0xff, 0x6d, 0xff, 0x7c, 0xff, 0x6d, 0xff, 0x58, 0xff, 0x87, 0xff, 0xc1, 0xff, 0xc3, 0xff, 0xe6, 0xff, 0x17, 0x00, 0x22, 0x00, 0x3d, 0x00, 0x58, 0x00, 0x4f, 0x00, 0x50, 0x00, 0x26, 0x00, 0xfa, 0xff, 0x5d, 0x00, 0x8a, 0x00, 0x32, 0x00, 0x75, 0x00, 0x22, 0x01, 0x0d, 0x01, 0xfe, 0x00, 0x48, 0x01, 0xd4, 0x00, 0x98, 0x00, 0x9f, 0x00, 0x40, 0x00, 0x62, 0x00, 0x35, 0x00, 0xe5, 0xff, 0x55, 0x00, 0x68, 0x00, 0x41, 0x00, 0x25, 0x00, 0xf0, 0xff, 0xef, 0xff, 0xd9, 0xff, 0x99, 0xff, 0x3f, 0xff, 0x3a, 0xff, 0x53, 0xff, 0x23, 0xff, 0x5a, 0xff, 0x70, 0xff, 0x83, 0xff, 0xc4, 0xff, 0x6a, 0xff, 0x7a, 0xff, 0xad, 0xff, 0x62, 0xff, 0x6e, 0xff, 0x7b, 0xff, 0x41, 0xff, 0x24, 0xff, 0x56, 0xff, 0x7f, 0xff, 0xc6, 0xff, 0xf9, 0xff, 0xd3, 0xff, 0x3d, 0x00, 0x65, 0x00, 0x49, 0x00, 0xa6, 0x00, 0x85, 0x00, 0x6b, 0x00, 0x78, 0x00, 0x27, 0x00, 0x2e, 0x00, 0x6a, 0x00, 0x34, 0x00, 0x01, 0x00, 0x49, 0x00, 0x81, 0x00, 0x84, 0x00, 0x78, 0x00, 0x58, 0x00, 0x49, 0x00, 0x6f, 0x00, 0x70, 0x00, 0x51, 0x00, 0x9e, 0x00, 0x53, 0x00, 0xe2, 0xff, 0x49, 0x00, 0x2e, 0x00, 0xe2, 0xff, 0xc8, 0xff, 0x70, 0xff, 0x80, 0xff, 0xa6, 0xff, 0x8f, 0xff, 0xd1, 0xff, 0x1f, 0x00, 0xf0, 0xff, 0xab, 0xff, 0x88, 0xff, 0x93, 0xff, 0x80, 0xff, 0x11, 0xff, 0x20, 0xff, 0x85, 0xff, 0xb5, 0xff, 0xe2, 0xff, 0x02, 0x00, 0x2c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x4a, 0x00, 0x56, 0x00, 0x29, 0x00, 0x0f, 0x00, 0x36, 0x00, 0x3c, 0x00, 0x58, 0x00, 0x62, 0x00, 0x65, 0x00, 0x98, 0x00, 0xc7, 0x00, 0xa4, 0x00, 0x64, 0x00, 0xa0, 0x00, 0x83, 0x00, 0xff, 0xff, 0x05, 0x00, 0x2e, 0x00, 0x18, 0x00, 0xe3, 0xff, 0x9b, 0xff, 0xa2, 0xff, 0xfb, 0xff, 0xaf, 0xff, 0x5d, 0xff, 0xca, 0xff, 0xd4, 0xff, 0xa7, 0xff, 0xbe, 0xff, 0xe2, 0xff, 0x07, 0x00, 0xc7, 0xff, 0x7f, 0xff, 0xa7, 0xff, 0xc3, 0xff, 0xaf, 0xff, 0xbb, 0xff, 0xcc, 0xff, 0xcc, 0xff, 0xa1, 0xff, 0xa0, 0xff, 0x26, 0x00, 0x22, 0x00, 0xb3, 0xff, 0xe4, 0xff, 0x35, 0x00, 0x3e, 0x00, 0x2c, 0x00, 0x10, 0x00, 0x00, 0x00, 0x16, 0x00, 0x28, 0x00, 0x1d, 0x00 };
  static guint8 expected_outbuf[98] = { 0x3f, 0xf9, 0x2a, 0x5a, 0x5b, 0x8c, 0x63, 0x10, 0xff, 0x3e, 0x99, 0xee, 0x1a, 0x1a, 0xd7, 0x13, 0x3f, 0xe2, 0xbf, 0x08, 0x35, 0x78, 0x99, 0x3f, 0x11, 0xe6, 0x92, 0xf1, 0xa5, 0x74, 0x3e, 0x96, 0xeb, 0xff, 0xf9, 0xeb, 0xa2, 0xe4, 0x36, 0x58, 0x62, 0x2d, 0x59, 0xb7, 0xe8, 0x0c, 0x7e, 0xbb, 0x46, 0x08, 0x04, 0x66, 0xb2, 0x78, 0x9b, 0xb6, 0x59, 0xe3, 0xad, 0xe4, 0x17, 0x4b, 0x7e, 0x9c, 0x63, 0x18, 0x87, 0xf9, 0xf0, 0x00, 0x04, 0x75, 0x90, 0xfd, 0xff, 0x7e, 0xd4, 0x5f, 0xc8, 0x59, 0x05, 0xb6, 0xc2, 0xb3, 0xf2, 0x85, 0x0a, 0x14, 0x20, 0x7f, 0x9f, 0x67, 0xcf, 0xde, 0xa6, 0x52, 0xce, 0x40 };
  guint8 outbuf[640] = { 0, };
  guint outbuf_size = sizeof (outbuf);

#ifndef G_OS_WIN32
  Setup_LDT_Keeper ();

  Check_FS_Segment ();
#endif

#ifdef ENABLE_FP_DEBUG
#ifdef G_OS_WIN32
  _control87 (~(_EM_INVALID | _EM_DENORMAL | _EM_ZERODIVIDE | _EM_OVERFLOW | _EM_UNDERFLOW) & _CW_DEFAULT, _MCW_EM);
#else
  feenableexcept (FE_ALL_EXCEPT & (~FE_INEXACT));
#endif
#endif

  printf ("calling LoadLibrary\n");
  mod = LoadLibraryA ("RTMPLTFM.dll");
  printf ("mod = 0x%08x\n", mod);

#ifdef G_OS_WIN32
  /*patch_crt_functions ();*/
#endif

  create_func = (MSEncoderCreateFunc) ((guint8 *) mod + (0x53df8e - 0x400000));
  destroy_func = (MSEncoderDestroyFunc) ((guint8 *) mod + (0x53e190 - 0x400000));

#if 0
#ifdef G_OS_WIN32
  {
    CpuCheckFunc cpu_check = (CpuCheckFunc) ((guint8 *) mod + (0x53CE51 - 0x400000));
    cpu_check ();

    block_rw_segments (mod);
  }
#endif
#endif

  printf ("calling create_func\n");
  ret = create_func (&encoder);
  printf ("create_func ret = 0x%08x, encoder = %p\n", ret, encoder);

  printf ("calling ms_encoder_init\n");
  ret = ms_encoder_init (encoder);
  printf ("ms_encoder_init ret = 0x%08x\n", ret);

  printf ("calling ms_encoder_set_bitrate\n");
  ret = ms_encoder_set_bitrate (encoder, 29000);
  printf ("ms_encoder_set_bitrate ret = 0x%08x\n", ret);

  /*my_log_dump_mem_chunks ();*/

  printf ("calling ms_encoder_encode with inbuf=%p, outbuf=%p\n", inbuf, outbuf);
  ret =
      ms_encoder_encode (encoder, inbuf, sizeof (inbuf), outbuf, &outbuf_size);
  printf ("ms_encoder_encode ret = 0x%08x\n", ret);

  if (outbuf_size == sizeof (expected_outbuf))
  {
    if (memcmp (outbuf, expected_outbuf, outbuf_size) == 0)
    {
      printf ("perfect match!\n");
    }
    else
    {
      printf ("mismatch :(\n");
    }
  }
  else
  {
    printf ("outbuf_size is %d, expected %d\n", outbuf_size,
        sizeof (expected_outbuf));
  }

#if 0
  g_debug ("calling destroy_func");
  ret = destroy_func (encoder);
  g_debug ("destroy_func ret = 0x%08x", ret);
#endif

  return 0;
}

